Identifier:
   #"[a-zA-Z][a-zA-Z0-9$_]*"


ImportDeclaration:
   import [static] Identifier { . Identifier } [. *] ;


ElementValues:
   ElementValue { , ElementValue }


AnnotationMethodRest:
   ( ) [[]] [default ElementValue]


ConstantDeclarator:
   Identifier ConstantDeclaratorRest


ConstantDeclaratorRest:
   {[]} = VariableInitializer


ConstantDeclaratorsRest:
   ConstantDeclaratorRest { , ConstantDeclarator }


InterfaceMethodOrFieldRest:
   ConstantDeclaratorsRest ;
   InterfaceMethodDeclaratorRest


AnnotationMethodOrConstantRest:
   AnnotationMethodRest
   ConstantDeclaratorsRest


AnnotationTypeElementRest:
   Type Identifier AnnotationMethodOrConstantRest ;
   ClassDeclaration
   InterfaceDeclaration
   EnumDeclaration
   AnnotationTypeDeclaration


AnnotationTypeElementDeclaration:
   {Modifier} AnnotationTypeElementRest


AnnotationTypeElementDeclarations:
   AnnotationTypeElementDeclaration
   AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration


AnnotationTypeBody:
   { [AnnotationTypeElementDeclarations] }


AnnotationTypeDeclaration:
   @ interface Identifier AnnotationTypeBody


VoidInterfaceMethodDeclaratorRest:
   FormalParameters [throws QualifiedIdentifierList] ;


InterfaceGenericMethodDecl:
   TypeParameters (Type | void) Identifier InterfaceMethodDeclaratorRest


InterfaceMethodDeclaratorRest:
   FormalParameters {[]} [throws QualifiedIdentifierList] ;


InterfaceMethodOrFieldDecl:
   Type Identifier InterfaceMethodOrFieldRest


EnumBodyDeclarations:
   ; {ClassBodyDeclaration}


Annotations:
   Annotation {Annotation}


EnumConstant:
   [Annotations] Identifier [Arguments] [ClassBody]


EnumConstants:
   EnumConstant
   EnumConstants , EnumConstant


EnumBody:
   { [EnumConstants] [,] [EnumBodyDeclarations] }


EnumDeclaration:
   enum Identifier [implements TypeList] EnumBody


VoidMethodDeclaratorRest:
   FormalParameters [throws QualifiedIdentifierList] (Block | ;)


ConstructorDeclaratorRest:
   FormalParameters [throws QualifiedIdentifierList] Block


GenericMethodOrConstructorRest:
   (Type | void) Identifier MethodDeclaratorRest
   Identifier ConstructorDeclaratorRest


GenericMethodOrConstructorDecl:
   TypeParameters GenericMethodOrConstructorRest


FieldDeclaratorsRest:
   VariableDeclaratorRest { , VariableDeclarator }


FormalParameterDeclsRest:
   VariableDeclaratorId [ , FormalParameterDecls ]
   ... VariableDeclaratorId


FormalParameterDecls:
   {VariableModifier}  Type FormalParameterDeclsRest


FormalParameters:
   ( [FormalParameterDecls] )


VariableDeclarators:
   VariableDeclarator { , VariableDeclarator }


LocalVariableDeclarationStatement:
   { VariableModifier }  Type VariableDeclarators ;


Resource:
   {VariableModifier} ReferenceType VariableDeclaratorId = Expression


Resources:
   Resource { ; Resource }


ResourceSpecification:
   ( Resources [;] )


VariableDeclaratorRest:
   {[]} [ = VariableInitializer ]


VariableDeclarator:
   Identifier VariableDeclaratorRest


ForVariableDeclaratorsRest:
   [ = VariableInitializer ] { , VariableDeclarator }


ForVarControlRest:
   ForVariableDeclaratorsRest ; [Expression] ; [ForUpdate]
   : Expression


VariableDeclaratorId:
   Identifier {[]}


ForVarControl:
   {VariableModifier} Type VariableDeclaratorId  ForVarControlRest


ForInit:
   StatementExpression { , StatementExpression }


ForUpdate:
   StatementExpression { , StatementExpression }


ForControl:
   ForVarControl
   ForInit ; [Expression] ; [ForUpdate]


EnumConstantName:
   Identifier


SwitchLabel:
   #"case" Expression :
   #"case" EnumConstantName :
   #"default" :


SwitchLabels:
   SwitchLabel { SwitchLabel }


SwitchBlockStatementGroup:
   SwitchLabels BlockStatements


SwitchBlockStatementGroups:
   { SwitchBlockStatementGroup }


CatchType:
   Identifier { | Identifier }



ElementValueArrayInitializer:
   { [ElementValues] [,] }


ElementValue:
   Annotation
   Expression1
   ElementValueArrayInitializer


ElementValuePair:
   Identifier = ElementValue


ElementValuePairs:
   ElementValuePair { , ElementValuePair }


AnnotationElement:
   ElementValuePairs
   ElementValue


Annotation:
   @ QualifiedIdentifier [ ( [AnnotationElement] ) ]


VariableModifier:
   final
   Annotation


CatchClause:
   catch ( {VariableModifier} CatchType Identifier ) Block


Catches:
   CatchClause { CatchClause }


Selector:
   . Identifier [Arguments]
   . ExplicitGenericInvocation
   . this
   . super SuperSuffix
   . new [NonWildcardTypeArguments] InnerCreator
   [ Expression ]


PostfixOp:
   ++
   --


PrefixOp:
   ++
   --
   !
   ~
   +
   -


NonWildcardTypeArgumentsOrDiamond:
   < >
   NonWildcardTypeArguments


InnerCreator:
   Identifier [NonWildcardTypeArgumentsOrDiamond] ClassCreatorRest


ExplicitGenericInvocation:
   NonWildcardTypeArguments ExplicitGenericInvocationSuffix


IdentifierSuffix:
   [ ( {[]} . class | Expression ) ]
   Arguments
   . ( class | ExplicitGenericInvocation | this | super Arguments | new [NonWildcardTypeArguments] InnerCreator )


ParExpression:
   ( Expression )


StringCharacter:
   #"InputCharacter but not " or \"
   EscapeSequence


StringCharacters:
   StringCharacter
   StringCharacters StringCharacter


StringLiteral:
   " StringCharacters ? "


OctalDigitOrUnderscore:
   OctalDigit
   _


OctalDigitsAndUnderscores:
   OctalDigitOrUnderscore
   OctalDigitsAndUnderscores OctalDigitOrUnderscore


OctalDigits:
   OctalDigit
   OctalDigit OctalDigitsAndUnderscores ? OctalDigit


OctalNumeral:
   #"0" OctalDigits
   #"0" Underscores OctalDigits


OctalIntegerLiteral:
   OctalNumeral IntegerTypeSuffix ?


BinaryDigit:
   0
   1


BinaryDigitOrUnderscore:
   BinaryDigit
   _


BinaryDigitsAndUnderscores:
   BinaryDigitOrUnderscore
   BinaryDigitsAndUnderscores BinaryDigitOrUnderscore


BinaryDigits:
   BinaryDigit
   BinaryDigit BinaryDigitsAndUnderscores ? BinaryDigit


BinaryNumeral:
   #"0b" BinaryDigits
   #"0B" BinaryDigits


BinaryIntegerLiteral:
   BinaryNumeral IntegerTypeSuffix ?


HexIntegerLiteral:
   HexNumeral IntegerTypeSuffix ?


Underscores:
   _
   Underscores _


DecimalNumeral:
   0
   NonZeroDigit Digits ?
   NonZeroDigit Underscores Digits


IntegerTypeSuffix:
   #"l|L"


DecimalIntegerLiteral:
   DecimalNumeral IntegerTypeSuffix ?


IntegerLiteral:
   DecimalIntegerLiteral
   HexIntegerLiteral
   OctalIntegerLiteral
   BinaryIntegerLiteral


NullLiteral:
   #"null"


BooleanLiteral:
   #"true"
   #"false"


ZeroToThree:
   #"[0-3]"


OctalDigit:
   #"[0-7]"


OctalEscape:
   \ OctalDigit
   \ OctalDigit OctalDigit
   \ ZeroToThree OctalDigit OctalDigit


EscapeSequence:
   #"\\b"
   #"\\t"
   #"\\n"
   #"\\f"
   #"\\r"
   #"\\\""
   #"\\'"
   #"\\\\"
   OctalEscape


SingleCharacter:
   #"InputCharacter but not ' or \"


CharacterLiteral:
   ' SingleCharacter '
   ' EscapeSequence '


ExponentIndicator:
   #"e|E"


ExponentPart:
   ExponentIndicator SignedInteger


DecimalFloatingPointLiteral:
   Digits . Digits ? ExponentPart ? FloatTypeSuffix ?
   . Digits ExponentPart ? FloatTypeSuffix ?
   Digits ExponentPart FloatTypeSuffix ?
   Digits ExponentPart ? FloatTypeSuffix


BinaryExponentIndicator:
   #"p|P"


Sign:
   #"+|-"


NonZeroDigit:
   #"[1-9]"


Digit:
   0
   NonZeroDigit


DigitOrUnderscore:
   Digit
   _


DigitsAndUnderscores:
   DigitOrUnderscore
   DigitsAndUnderscores DigitOrUnderscore


Digits:
   Digit
   Digit DigitsAndUnderscores ? Digit


SignedInteger:
   Sign ? Digits


BinaryExponent:
   BinaryExponentIndicator SignedInteger


HexNumeral:
   #"0x" HexDigits
   #"0X" HexDigits


HexDigit:
   #"[0-9a-fA-F]"


HexDigitOrUnderscore:
   HexDigit
   _


HexDigitsAndUnderscores:
   HexDigitOrUnderscore
   HexDigitsAndUnderscores HexDigitOrUnderscore


HexDigits:
   HexDigit
   HexDigit HexDigitsAndUnderscores ? HexDigit


HexSignificand:
   HexNumeral
   HexNumeral .
   #"0x" HexDigits ? . HexDigits
   #"0X" HexDigits ? . HexDigits


FloatTypeSuffix:
   #"f|F|d|D"


HexadecimalFloatingPointLiteral:
   HexSignificand BinaryExponent FloatTypeSuffix ?


FloatingPointLiteral:
   DecimalFloatingPointLiteral
   HexadecimalFloatingPointLiteral


Literal:
   IntegerLiteral
   FloatingPointLiteral
   BooleanLiteral
   CharacterLiteral
   StringLiteral
   NullLiteral


NonWildcardTypeArguments:
   < TypeList >


TypeArgumentsOrDiamond:
   < >
   TypeArguments


CreatedName:
   Identifier [TypeArgumentsOrDiamond] { . Identifier [TypeArgumentsOrDiamond] }


ClassCreatorRest:
   Arguments [ClassBody]


VariableInitializer:
   ArrayInitializer
   Expression


ArrayInitializer:
   { [ VariableInitializer { , VariableInitializer } [,] ] }


ArrayCreatorRest:
   [ ( ] {[]} ArrayInitializer | Expression ] {[ Expression ]} {[]} ) ]


Creator:
   NonWildcardTypeArguments CreatedName ClassCreatorRest
   CreatedName ( ClassCreatorRest | ArrayCreatorRest )


Arguments:
   ( [ Expression { , Expression } ] )


SuperSuffix:
   Arguments
   . Identifier [Arguments]


ExplicitGenericInvocationSuffix:
   super SuperSuffix
   Identifier Arguments


Primary:
   Literal
   ParExpression
   this [Arguments]
   super SuperSuffix
   new Creator
   NonWildcardTypeArguments ( ExplicitGenericInvocationSuffix | this Arguments )
   Identifier { . Identifier } [IdentifierSuffix]
   BasicType {[]} . class
   void . class


Expression3:
   PrefixOp Expression3
   ( Expression | Type ) Expression3
   Primary { Selector } { PostfixOp }


BasicType:
   #"byte"
   #"short"
   #"char"
   #"int"
   #"long"
   #"float"
   #"double"
   #"boolean"


Type:
   BasicType {[]}
   ReferenceType  {[]}


InfixOp:
   ||
   &&
   |
   ^
   &
   ==
   !=
   <
   >
   <=
   >=
   <<
   >>
   >>>
   +
   -
   *
   /
   %


Expression2Rest:
   { InfixOp Expression3 }
   instanceof Type


Expression2:
   Expression3 [ Expression2Rest ]


Expression1Rest:
   ? Expression : Expression1


Expression1:
   Expression2 [ Expression1Rest ]


AssignmentOperator:
   =
   +=
   -=
   *=
   /=
   &=
   |=
   ^=
   %=
   <<=
   >>=
   >>>=


Expression:
   Expression1 [ AssignmentOperator Expression1 ]


StatementExpression:
   Expression


Finally:
   #"finally" Block


Statement:
   Block
   ;
   Identifier : Statement
   StatementExpression ;
   #"if" ParExpression Statement [else Statement]
   #"assert" Expression [: Expression] ;
   #"switch" ParExpression { SwitchBlockStatementGroups }
   #"while" ParExpression Statement
   #"do" Statement while ParExpression ;
   #"for" ( ForControl ) Statement
   #"break" [Identifier] ;
   #"continue" [Identifier] ;
   #"return" [Expression] ;
   #"throw" Expression ;
   #"synchronized" ParExpression Block
   #"try" Block ( Catches | [Catches] Finally )
   #"try" ResourceSpecification Block [Catches] [Finally]


BlockStatement:
   LocalVariableDeclarationStatement
   ClassOrInterfaceDeclaration
   [Identifier :] Statement


BlockStatements:
   { BlockStatement }


Block:
   { BlockStatements }


QualifiedIdentifier:
   Identifier { . Identifier }


QualifiedIdentifierList:
   QualifiedIdentifier { , QualifiedIdentifier }


MethodDeclaratorRest:
   FormalParameters {[]} [throws QualifiedIdentifierList] (Block | ;)


MethodOrFieldRest:
   FieldDeclaratorsRest ;
   MethodDeclaratorRest


MethodOrFieldDecl:
   Type Identifier MethodOrFieldRest


MemberDecl:
   MethodOrFieldDecl
   #"void" Identifier VoidMethodDeclaratorRest
   Identifier ConstructorDeclaratorRest
   GenericMethodOrConstructorDecl
   ClassDeclaration
   InterfaceDeclaration


ClassBodyDeclaration:
   #";"
   {Modifier} MemberDecl
   [static] Block


ClassBody:
   { { ClassBodyDeclaration } }


NormalClassDeclaration:
   class Identifier [TypeParameters] [extends Type] [implements TypeList] ClassBody


ClassDeclaration:
   NormalClassDeclaration
   EnumDeclaration


InterfaceMemberDecl:
   InterfaceMethodOrFieldDecl
   void Identifier VoidInterfaceMethodDeclaratorRest
   InterfaceGenericMethodDecl
   ClassDeclaration
   InterfaceDeclaration


Modifier:
   #"Annotation"
   #"public"
   #"protected"
   #"private"
   #"static"
   #"abstract"
   #"final"
   #"native"
   #"synchronized"
   #"transient"
   #"volatile"
   #"strictfp"


InterfaceBodyDeclaration:
   #";"
   {Modifier} InterfaceMemberDecl


InterfaceBody:
   { { InterfaceBodyDeclaration } }


TypeList:
   ReferenceType { , ReferenceType }


TypeArgument:
   ReferenceType
   ? [ ( extends | super ) ReferenceType ]


TypeArguments:
   < TypeArgument { , TypeArgument } >


ReferenceType:
   Identifier [TypeArguments] { . Identifier [TypeArguments] }


Bound:
   ReferenceType { & ReferenceType }



TypeParameter:
   Identifier [extends Bound]


TypeParameters:
   < TypeParameter { , TypeParameter } >


NormalInterfaceDeclaration:
   interface Identifier [TypeParameters] [extends TypeList] InterfaceBody


InterfaceDeclaration:
   NormalInterfaceDeclaration
   AnnotationTypeDeclaration


ClassOrInterfaceDeclaration:
   {Modifier} (ClassDeclaration | InterfaceDeclaration)


TypeDeclaration:
   ClassOrInterfaceDeclaration
   ;


CompilationUnit:
   [ [Annotations] package QualifiedIdentifier ; ] {ImportDeclaration} {TypeDeclaration}


nil
doubletake.java.spec.core=>
