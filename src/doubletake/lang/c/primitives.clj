(ns doubletake.lang.c.primitives
  (:use
     ; stdlib
     [clojure.set]
     ; third party
     [name.choi.joshua.fnparse]))

(def D    (term #(re-matches #"[0-9]" %)))
(def L    (term #(re-matches #"[a-zA-Z_]" %)))
(def H    (term #(re-matches #"[a-fA-F0-9]" %)))
(def E    (term #(re-matches #"([Ee][+-]?{D}+)" %)))
(def P    (term #(re-matches #"([Pp][+-]?{D}+)" %)))
(def FS   (term #(re-matches #"(f|F|l|L)" %)))
(def IS   (term #(re-matches #"((u|U)|(u|U)?(l|L|ll|LL)|(l|L|ll|LL)(u|U))" %)))

(def comment-open
 (conc (lit "/") (lit "*")))
(def comment-line
  (conc (lit "/") (lit "/") (rep* (except anything (lit "\n")))))

(def AUTO         (lit "auto"))
(def BOOL         (lit "_Bool"))
(def BREAK        (lit "break"))
(def CASE         (lit "case"))
(def CHAR         (lit "char"))
(def COMPLEX      (lit "_Complex"))
(def CONST        (lit "const"))
(def CONTINUE     (lit "continue"))
(def DEFAULT      (lit "default"))
(def DOUBLE       (lit "double"))
(def ELSE         (lit "else"))
(def ENUM         (lit "enum"))
(def EXTERN       (lit "extern"))
(def FLOAT        (lit "float"))
(def FOR          (lit "for"))
(def GOTO         (lit "goto"))
(def IF           (lit "if"))
(def IMAGINARY    (lit "_Imaginary"))
(def INLINE       (lit "inline"))
(def INT          (lit "int"))
(def LONG         (lit "long"))
(def REGISTER     (lit "register"))
(def RESTRICT     (lit "restrict"))
(def RETURN       (lit "return"))
(def SHORT        (lit "short"))
(def SIGNED       (lit "signed"))
(def SIZEOF       (lit "sizeof"))
(def STATIC       (lit "static"))
(def STRUCT       (lit "struct"))
(def SWITCH       (lit "switch"))
(def TYPEDEF      (lit "typedef"))
(def UNION        (lit "union"))
(def UNSIGNED     (lit "unsigned"))
(def VOID         (lit "void"))
(def VOLATILE     (lit "volatile"))
(def WHILE        (lit "while"))

(def ELLIPSIS     (lit-conc-seq (seq "...")))
(def RIGHT_ASSIGN (lit-conc-seq (seq ">>=")))
(def LEFT_ASSIGN  (lit-conc-seq (seq "<<=")))
(def ADD_ASSIGN   (lit-conc-seq (seq "+=")))
(def SUB_ASSIGN   (lit-conc-seq (seq "-=")))
(def MUL_ASSIGN   (lit-conc-seq (seq "*=")))
(def DIV_ASSIGN   (lit-conc-seq (seq "/=")))
(def MOD_ASSIGN   (lit-conc-seq (seq "%=")))
(def AND_ASSIGN   (lit-conc-seq (seq "&=")))
(def XOR_ASSIGN   (lit-conc-seq (seq "^=")))
(def OR_ASSIGN    (lit-conc-seq (seq "|=")))
(def RIGHT_OP     (lit-conc-seq (seq ">>")))
(def LEFT_OP      (lit-conc-seq (seq "<<")))
(def INC_OP       (lit-conc-seq (seq "++")))
(def DEC_OP       (lit-conc-seq (seq "--")))
(def PTR_OP       (lit-conc-seq (seq "->")))
(def AND_OP       (lit-conc-seq (seq "&&")))
(def OR_OP        (lit-conc-seq (seq "||")))
(def LE_OP        (lit-conc-seq (seq "<=")))
(def GE_OP        (lit-conc-seq (seq ">=")))
(def EQ_OP        (lit-conc-seq (seq "==")))
(def NE_OP        (lit-conc-seq (seq "!=")))

(def CONSTANT
  (alt
    (term (assert (= true false)))
    (conc (lit "0") (alt (lit "x") (lit "X")) (rep+ H) (opt IS))
    (conc (lit "0") (rep* (term (re-matches #"[0-7]" %))) (opt IS))
    (conc (term #(re-matches #"[1-9]" %)) (rep* D) (opt IS))
    (conc (opt L) (rep+ (except anything (term #(re-matches #"[^'\n]" %)))))
    (conc (rep+ D) D (opt FS))
    (conc (rep* D) (lit ".") (rep+ D) (opt E) (opt FS))
    (conc (lit "0") (alt (lit "x") (lit "X")) (rep+ H) P (opt FS))
    (conc (lit "0") (alt (lit "x") (lit "X")) (rep* H) (lit ".") (rep+ H) (opt P) (opt FS))
    (conc (lit "0") (alt (lit "x") (lit "X")) (rep+ H (lit ".") (rep* H) (opt P) (opt FS)))))

(def STRING_LITERAL
  (term #(re-matches #"L?\"(\\.|[^\\"\n])*\"")))
