(ns doubletake.ast
  (:require [clojure.stacktrace]
            [clojure.pprint]
            [clojure.data]
            [clojure.set :as set]
            [doubletake.levenshtein :as levenshtein])
  (:import  [org.eclipse.jdt.core.dom ASTNode
                                      Assignment
                                      VariableDeclaration
                                      VariableDeclarationStatement
                                      VariableDeclarationExpression]))

; One of the really sticky points in this project so far has been the actual
; data  representation of the AST as Doubletake has to deal with it.  Eclipse
; has one AST which it uses internally, but while providing an effective and
; clean interface from Java it is really shitty when regarded from the Clojure
; side of things because it defeats all simple recursion approaches and 
; also makes Clojure's definition of equality unusable for evaluating
; equivalence.
;
; As a result, this file will spedify an AST structure internal to Doubletake
; anmd derived from the Eclipse AST which will strive to retain as much
; information from the Eclipse AST as possible while presenting the same data
; in a more Clojure-friendly list based format.

(defn sorta-equal 
  "About:
    This routine is intended for use in asserting and testing the rough
    equality of Eclipse AST nodes. As the AST nodes are heavily typed (#Java)
    that information can be used to say 'well I have no idea whether the
    metadata about these two line up but frankly I don't care, they are IFs,
    assume equality of the node and examine the subtrees'
  
    In short it's a custom definition of equality for the pourpose of kludging
    something useful out of the Eclipse syntax tree without doing a wholesale
    conversion to a Clojure style list.

  Arguments:
    This function takes two Objects, and tests whether their topmost base class
    is the same. Intended for ASTNodes, but correct for all Objects.
  "
  [node-a node-b]
  (= (class node-a) (class node-b)))

(defn subtrees-of-node
  "About:
    This routine yields the subtrees, if any, of the input object which  MUST
    superclass the Eclipse ASTNode.

    This routine is indented to function as part of my kludge to recur through
    the Eclipse AST as though it were a standard Lisp-style nested list struct.
    The 'good' news is that the list of structural properties is constant by
    type so the resulting AST should have a very sane structure.

  Arguments:
    A single Object which instances a subclass of the Eclipse ASTNode"
  [^ASTNode node]
  (map #(.getStructuralProperty node %1)
       (.structuralPropertiesForType node)))

(defn eAST->cAST
  "About:
    Really bad name asside, this function takes an Eclipse AST and recursively
    converts it to a more Clojure-ey form by application of the above
    subtrees-of-node function.

    The resulting lists are of the form (concat [node] (subtrees-of-node node))

  Arguments:
    This function takes a single ASTNode argument and returns a list of lists
    of... I think you get the picture."
  [^ASTNode node]
  (concat [node]
          (map eAST->cAST
               (subtrees-of-node node))))

(defn cAST-diff 
  "About:
    Given two arbitrary (but presumably related) Clojure list representations
    of ASTs as generated by eAST->cAST, diffs it using the Levenshtein library
    and yields a list of all the non-null nodes which the diff suggests are
    points of change.
  Arguments:
    This function is intended to be invoked with two list-formatted ASTs, but
    since it invokes (flatten), it may be correct for arbitrary sequences."
  [ast1 ast2]
  (let [s1 (flatten ast1)
        s2 (flatten ast2)]
    (levenshtein/levenshtein-data->script
      (levenshtein/levenshtein-calculation s1 s2 :equality sorta-equal))))

(def assignment-types
  #{Assignment 
    VariableDeclaration 
    VariableDeclarationStatement 
    VariableDeclarationExpression})

(defn get-change-defs
  "About:
    Takes the edit script and the two sequences over which it was computed
    and computes the list of actuall obejcts which were subjected to change.
  Arguments:
    The edit sequence, the initial and final sequences.
  Returns:
    The list of non-nil objects which are subjected to change."
  [script seq1 seq2]
  (let [better-edits 
            (map #(levenshtein/edit->better-edit % seq1 seq2) script)
        insertions 
            (remove nil? (map #(:value-final (second %) nil) better-edits))
        deletions  
            (remove nil? (map #(:value-init  (second %) nil) better-edits))
        ins-defs (remove #(empty? (set/intersection (supers %1) assignment-types))
                         insertions)
        del-defs (remove #(empty? (set/intersection (supers %1) assignment-types))
                         deletions)]
    {:inserted-defs ins-defs
     :deleted-defs  del-defs}))
